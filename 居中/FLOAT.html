<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>float</title>
	<style type="text/css">
		.clear:after{
			content: "";
			display: table;
			clear: both;
		}
		.one{
			background: #f2f2f2;
/*			width: 1000px;*/
			height: 400px;
		}
		.two{
			background: #1AB25B;
			float: left;
			position: relative;
			height: 300px;
			left: 50%;
			top: 50%;

		}
		.three{
			background: #267E9F;
			position: relative;
			left: -50%;
			width: 100%;
			top: -50%;
			height: 100%;
		}
	</style>
</head>
<body>
	<div class="one clear">
		<div class="two">
			<div class="three">
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中
			</div>
		</div>
	</div>

	<br><br><br><br>
	<div class="one clear">
		<span class="two" style="display:inline-block">
			<span class="three">
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中<br>
				利用浮动水平居中
			</span>
		</span>
	</div>
</body>
</html>


<!-- tip:利用相对定位可以实现居中（水平居中完美兼容，垂直居中特定条件下可以实现）

原理：根据元素相对定位的特性，对其left / top使用百分比值时，其会根据父元素的值来进行计算。所以这里需要在居中层（目标层）与其父元素（父元素层）层中多嵌套一层结构（中间层）称来实现。而方法的关键就在于中间层的设定。
对中间层使用相对定位，让其left为50%;即让其左端偏移到父元素的左端（left / top 的百分比值相对父元素计算得出）。
此时，如果对目标层也使用相对定位，让目标层的left / top 以自身的宽度/高度的-50%偏移回来即可实现居中。（这与绝对定位的居中原理相同）。

但是，怎么让目标层的left / top 以自身的宽度/高度的-50%偏移回来呢？我们知道left / height的值时以父元素的百分比计算的而并不是以自身的值来计算的。（这一点在网上诸多资料中都会导致误导）。
所以此时，又涉及到了css的盒模型、继承等相关特性。
方法一：（也是网上最常见的方法）对中间层使用浮动即可。
方法二：将中间层display成inline / inline-block即可。
方法三：手动设置中间层的width / height，另其与目标层的width / height相等。

方法一、二对height（也就是垂直居中不管用），因为浮动元素 / inline / inline-block元素的宽度在不设置的时候，会默认等于内容区（即子元素的盒模型），而height并不具有这个特性，所以如果不对height设定数值，目标层的top是无效的。

所以如果想使用此方法实现垂直居中，必须明确知道目标层（目标层不能为行内元素）的高度，并且手动设置目标层与中间层的高度相等。

此外，在例子2中，实际上元素是已经垂直居中了的（top值是相对父元素计算的），但是如果目标层是行内元素，对其设置height是无效的，如果把目标设置成block / inline-block并把height设置成100%，即可以看出是居中的。


相对定位下的绝对定位，原理与上相同，不需要中间层，但是需要明确知道目标层的高度 / 宽度，才能实现实现水平 / 垂直居中,使用一个负的margin-left或margin-top的值来把它拉回到居中的位置，这个负的margin值就取元素宽度或高度的一半。。 -->